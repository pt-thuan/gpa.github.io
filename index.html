  <div class="result" id="output"></div>

  <script>
    function calculate() {
      const completedGPA = parseFloat(document.getElementById("completedGPA").value);
      const completedCredits = parseFloat(document.getElementById("completedCredits").value);
      const remainingCredits = parseFloat(document.getElementById("remainingCredits").value);
      const targetGPA = parseFloat(document.getElementById("targetGPA").value);

      const outputDiv = document.getElementById("output");

      if (
        isNaN(completedGPA) ||
        isNaN(completedCredits) ||
        isNaN(remainingCredits) ||
        isNaN(targetGPA)
      ) {
        outputDiv.innerHTML = "‚ùó Please fill in all fields with valid numbers.";
        return;
      }

      const totalCredits = completedCredits + remainingCredits;
      const totalRequiredPoints = targetGPA * totalCredits;
      const currentPoints = completedGPA * completedCredits;
      const requiredPoints = totalRequiredPoints - currentPoints;
      const requiredGPA = requiredPoints / remainingCredits;

      let message = `‚úÖ You need to average at least GPA ${requiredGPA.toFixed(2)} in the remaining ${remainingCredits} credits.<br><br>`;

      const grades = [
        { name: "A+", value: 4.0 },
        { name: "A", value: 3.7 },
        { name: "B+", value: 3.5 },
        { name: "B", value: 3.0 },
        { name: "C+", value: 2.5 },
        { name: "C", value: 2.0 },
        { name: "D+", value: 1.5 },
        { name: "D", value: 1.0 }
      ];

      const creditRemainder = remainingCredits % 3;

      if (creditRemainder !== 0) {
        message += "‚ö†Ô∏è Grade allocation options are not available as remaining credits are not divisible by 3.";
        outputDiv.innerHTML = message;
        return;
      }

      const combinations = [];

      function findCombos(index, usedCredits, usedPoints, combo) {
        if (usedCredits === remainingCredits) {
          const gpa = usedPoints / remainingCredits;
          if (gpa >= requiredGPA - 0.01) {
            combinations.push([...combo]);
          }
          return;
        }

        if (index >= grades.length || usedCredits > remainingCredits) return;

        const maxPossibleUnits = (remainingCredits - usedCredits) / 3;
        for (let count = 0; count <= maxPossibleUnits; count++) {
          combo.push({ grade: grades[index].name, credits: count * 3 });
          findCombos(index + 1,
                     usedCredits + count * 3,
                     usedPoints + count * 3 * grades[index].value,
                     combo);
          combo.pop();
        }
      }

      findCombos(0, 0, 0, []);

      combinations.sort((a, b) => {
        const score = (combo) =>
          combo.reduce((sum, g) => sum + g.credits * grades.find(gr => gr.name === g.grade).value, 0);
        return score(a) - score(b);
      });

      if (combinations.length === 0) {
        message += "‚ö†Ô∏è No feasible combinations found with common grades.";
      } else {
        message += "üéØ <b>Possible Grade Allocations (by credits):</b><br>";
        combinations.slice(0, 5).forEach((combo, idx) => {
          const comboText = combo
            .filter(g => g.credits > 0)
            .map(g => `${g.credits} credits of grade ${g.grade}`)
            .join(", ");
          message += `Option ${idx + 1}: ${comboText}<br>`;
        });
      }

      outputDiv.innerHTML = message;
    }
  </script>

</body>
</html>
